{"version":3,"file":"legacyDateFormat.mjs","sources":["../src/datetime-formatter/sanitizeLocale.ts","../src/datetime-formatter/formatter.ts","../src/datetime-formatter/momentToDateFnsFormat.ts","../src/legacyDateFormat.ts"],"sourcesContent":["// this is used to avoid issues with the Intl.DateTimeFormat constructor as part of the efps tests\nconst sanitizeLocale = (locale: string): string => locale.replace(/@posix$/, '')\n\nexport default sanitizeLocale\n","import {format} from 'date-fns'\n\nimport sanitizeLocale from './sanitizeLocale'\n\nfunction getMonthName(\n  date: Date,\n  style: 'long' | 'short' | 'narrow' | undefined = 'long',\n  locale = 'en-US',\n): string {\n  const validLocale = sanitizeLocale(locale)\n  return new Intl.DateTimeFormat(validLocale, {month: style}).format(date)\n}\n\nfunction getDayName(\n  date: Date,\n  style: 'long' | 'short' | 'narrow' | undefined = 'long',\n  locale = 'en-US',\n): string {\n  const validLocale = sanitizeLocale(locale)\n  return new Intl.DateTimeFormat(validLocale, {weekday: style}).format(date)\n}\n\n/**\n * Zero-pads a number to `length` digits (e.g. zeroPad(7, 2) = \"07\").\n */\nfunction zeroPad(num: number, length: number): string {\n  return String(num).padStart(length, '0')\n}\n\n/**\n * Returns an English ordinal for a given day number\n */\nfunction getOrdinal(day: number): string {\n  const j = day % 10\n  const k = day % 100\n  if (j === 1 && k !== 11) return `${day}st`\n  if (j === 2 && k !== 12) return `${day}nd`\n  if (j === 3 && k !== 13) return `${day}rd`\n  return `${day}th`\n}\n\nfunction getISODayOfWeek(date: Date): number {\n  // Sunday=0 in JS, but ISO calls Monday=1...Sunday=7\n  const dow = date.getDay()\n  return dow === 0 ? 7 : dow\n}\n\nfunction getISOWeekYear(date: Date): number {\n  // Clone date, shift to the \"Thursday\" of this week\n  const temp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()))\n  const dayOfWeek = getISODayOfWeek(temp)\n  temp.setUTCDate(temp.getUTCDate() - dayOfWeek + 4)\n  return temp.getUTCFullYear()\n}\n\nfunction getISOWeekNumber(date: Date): number {\n  const temp = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()))\n  const dayOfWeek = getISODayOfWeek(temp)\n  temp.setUTCDate(temp.getUTCDate() - dayOfWeek + 4)\n  const yearStart = new Date(Date.UTC(temp.getUTCFullYear(), 0, 1))\n  return Math.ceil(((temp.valueOf() - yearStart.valueOf()) / 86400000 + 1) / 7)\n}\n\nfunction getDayOfYear(date: Date): number {\n  const startOfYear = new Date(Date.UTC(date.getFullYear(), 0, 1))\n  // fix for local-time differences\n  const diff =\n    date.valueOf() -\n    startOfYear.valueOf() +\n    (startOfYear.getTimezoneOffset() - date.getTimezoneOffset()) * 60_000\n  return Math.floor(diff / (1000 * 60 * 60 * 24)) + 1\n}\n\n// \"Locale\" week-year => approximate with ISO logic here\nfunction getLocaleWeekYear(date: Date): number {\n  return getISOWeekYear(date)\n}\n\n/**\n * Returns fractional seconds based on the count of 'S' in the token.\n */\nfunction getFractionalSeconds(date: Date, length: number): string {\n  const ms = zeroPad(date.getMilliseconds(), 3) // \"123\"\n  if (length === 1) {\n    return ms.slice(0, 1) // \"1\"\n  } else if (length === 2) {\n    return ms.slice(0, 2) // \"12\"\n  } else if (length === 3) {\n    return ms // \"123\"\n  }\n  // length=4 => e.g. \"1230\"\n  return `${ms}0`\n}\n\nfunction getTimeZoneAbbreviation(date: Date) {\n  const parts = new Intl.DateTimeFormat(sanitizeLocale('en-US'), {\n    timeZoneName: 'short',\n  }).formatToParts(date)\n  const tz = parts.find((part) => part.type === 'timeZoneName')\n  return tz ? tz.value : ''\n}\n\n/**\n * Formats a Date object using many Moment-like tokens.\n */\nfunction formatMomentLike(date: Date, formatStr: string): string {\n  // Store escaped sequences to restore later\n  const escapeSequences: string[] = []\n  const escapeToken = '\\uE000' // Use a Unicode private use character as placeholder\n\n  // Replace bracketed content with placeholders\n  const processedFormat = formatStr.replace(/\\[([^\\]]+)\\]/g, (_, contents) => {\n    escapeSequences.push(contents)\n    return escapeToken\n  })\n\n  // Basic fields\n  const year = date.getFullYear()\n  const monthIndex = date.getMonth() // 0..11\n  const dayOfMonth = date.getDate() // 1..31\n  const dayOfWeek = date.getDay() // 0..6 (Sun=0)\n  const hours = date.getHours() // 0..23\n  const minutes = date.getMinutes() // 0..59\n  const seconds = date.getSeconds() // 0..59\n\n  // Week-related\n  const isoWeekNum = getISOWeekNumber(date)\n  const isoWeekYear = getISOWeekYear(date)\n  const localeWeekYear = getLocaleWeekYear(date)\n\n  // Timestamps\n  const unixMs = date.getTime() // milliseconds since epoch\n  const unixSec = Math.floor(unixMs / 1000) // seconds since epoch\n\n  // Build token -> value map\n  const tokens = [\n    // Year\n    // 1970 1971 ... 2029 2030\n    {key: 'YYYY', value: String(year)},\n    // 70 71 ... 29 30\n    {key: 'YY', value: String(year).slice(-2)},\n    // 1970 1971 ... 9999 +10000 +10001\n    {key: 'Y', value: String(year)},\n    // Expanded years, -001970 -001971 ... +001907 +001971\n    {key: 'YYYYY', value: zeroPad(year, 5)},\n\n    // ISO week-year\n    // 1970 1971 ... 2029 2030\n    {key: 'GGGG', value: String(isoWeekYear)},\n    // 70 71 ... 29 30\n    {key: 'GG', value: String(isoWeekYear).slice(-2)},\n\n    // \"locale\" week-year\n    {key: 'gggg', value: String(localeWeekYear)},\n    {key: 'gg', value: String(localeWeekYear).slice(-2)},\n\n    // Quarter\n    {key: 'Q', value: String(Math.floor(monthIndex / 3) + 1)},\n    {key: 'Qo', value: getOrdinal(Math.floor(monthIndex / 3) + 1)},\n\n    // --- Month (using Intl) ---\n    {key: 'MMMM', value: getMonthName(date, 'long')}, // e.g. \"January\"\n    {key: 'MMM', value: getMonthName(date, 'short')}, // e.g. \"Jan\"\n    // For numeric months, we still do a manual approach:\n    {key: 'MM', value: zeroPad(monthIndex + 1, 2)},\n    {key: 'M', value: String(monthIndex + 1)},\n    {key: 'Mo', value: getOrdinal(monthIndex + 1)},\n\n    // Day of Month\n    {key: 'DD', value: zeroPad(dayOfMonth, 2)},\n    {key: 'D', value: String(dayOfMonth)},\n    {key: 'Do', value: getOrdinal(dayOfMonth)},\n\n    // --- Day of Week (using Intl) ---\n    {key: 'dddd', value: getDayName(date, 'long')}, // e.g. \"Monday\"\n    {key: 'ddd', value: getDayName(date, 'short')}, // e.g. \"Mon\"\n    {\n      key: 'dd',\n      // e.g. \"Mo\" => first 2 chars of short day name\n      value: getDayName(date, 'short').slice(0, 2),\n    },\n    {key: 'd', value: String(dayOfWeek)},\n    {key: 'do', value: getOrdinal(dayOfWeek + 1)},\n\n    // Day of the year\n    {key: 'DDDD', value: zeroPad(getDayOfYear(date), 3)},\n    {key: 'DDD', value: String(getDayOfYear(date))},\n    {key: 'DDDo', value: getOrdinal(getDayOfYear(date))},\n\n    // ISO day of week\n    {key: 'E', value: String(getISODayOfWeek(date))},\n\n    // Day of Year\n    {key: 'DDDD', value: zeroPad(getDayOfYear(date), 3)},\n    {key: 'DDD', value: String(getDayOfYear(date))},\n\n    // Week of the year\n    // w 1 2 ... 52 53\n    {key: 'w', value: zeroPad(isoWeekNum, 2)},\n    // week 1st 2nd ... 52nd 53rd\n    {key: 'wo', value: getOrdinal(isoWeekNum)},\n    // 01 02 ... 52 53\n    {key: 'ww', value: zeroPad(isoWeekNum, 2)},\n\n    // ISO Week\n    {key: 'WW', value: zeroPad(isoWeekNum, 2)},\n    {key: 'W', value: String(isoWeekNum)},\n    {key: 'Wo', value: getOrdinal(isoWeekNum)},\n\n    // or \"locale\" week => replace isoWeekNum\n\n    // 24h hours\n    {key: 'HH', value: zeroPad(hours, 2)},\n    {key: 'H', value: String(hours)},\n\n    // 12h hours\n    {key: 'hh', value: zeroPad(((hours + 11) % 12) + 1, 2)},\n    {key: 'h', value: String(((hours + 11) % 12) + 1)},\n\n    // 1 2 ... 23 24\n    {key: 'k', value: String(hours || 24)},\n    // 01 02 ... 23 24\n    {key: 'kk', value: zeroPad(hours || 24, 2)},\n\n    // Minutes\n    {key: 'mm', value: zeroPad(minutes, 2)},\n    {key: 'm', value: String(minutes)},\n\n    // Seconds\n    {key: 'ss', value: zeroPad(seconds, 2)},\n    {key: 's', value: String(seconds)},\n\n    // Fractional seconds (S..SSSS) => handled separately\n    // Timezone offset (Z, ZZ) => handled separately\n\n    // AM/PM\n    {key: 'A', value: hours < 12 ? 'AM' : 'PM'},\n    {key: 'a', value: hours < 12 ? 'am' : 'pm'},\n\n    // Unix timestamps\n    {key: 'X', value: String(unixSec)},\n    {key: 'x', value: String(unixMs)},\n\n    // Eras BC AD\n    {key: 'N', value: year < 0 ? 'BC' : 'AD'},\n    {key: 'NN', value: year < 0 ? 'BC' : 'AD'},\n    {key: 'NNN', value: year < 0 ? 'BC' : 'AD'},\n\n    // Before Christ, Anno Domini\n    {key: 'NNNN', value: year < 0 ? 'Before Christ' : 'Anno Domini'},\n    {key: 'NNNNN', value: year < 0 ? 'BC' : 'AD'},\n\n    // Time zone offset\n    {key: 'z', value: getTimeZoneAbbreviation(date)},\n    {key: 'zz', value: getTimeZoneAbbreviation(date)},\n    {key: 'Z', value: format(date, 'xxx')},\n    {key: 'ZZ', value: format(date, 'xx')},\n  ]\n\n  // Sort tokens by descending length to avoid partial collisions\n  tokens.sort((a, b) => b.key.length - a.key.length)\n\n  // 1) Fractional seconds\n  const fracSecRegex = /(S{1,4})/g\n  let output = processedFormat.replace(fracSecRegex, (match) => {\n    return getFractionalSeconds(date, match.length)\n  })\n\n  // Find each token and replace it, make sure not to replace overlapping tokens\n\n  for (const {key, value} of tokens) {\n    // Escape special characters\n    const escapedKey = key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    // Match the token, but only if it's not part of a larger word\n    const tokenRegex = new RegExp(`(^|[^A-Z0-9a-z])(${escapedKey})(?![A-Z0-9a-z])`, 'g')\n    output = output.replace(tokenRegex, `$1${value}`)\n  }\n\n  // After all token replacements, restore escaped sequences\n  output = output.replace(new RegExp(escapeToken, 'g'), () => escapeSequences.shift() || '')\n\n  return output\n}\n\nexport default formatMomentLike\n","/**\n * Converts a Moment.js format string into a UTS 35 (Unicode Technical Standard #35)\n * format string\n *\n * This function doesn't take absolutely every token into account, but should cover\n * all common cases. If you find a missing token, feel free to add it.\n *\n */\nexport function momentToDateFnsFormat(momentFormat: string): string {\n  // A list of replacements from Moment tokens to date-fns tokens\n  // ordered from longest to shortest to prevent partial replacements\n  const formatMap: Record<string, string> = {\n    YYYY: 'yyyy',\n    YY: 'yy',\n    MMMM: 'MMMM',\n    MMM: 'MMM',\n    MM: 'MM',\n    M: 'M',\n    DD: 'dd',\n    D: 'd',\n    dddd: 'EEEE',\n    ddd: 'EEE',\n    HH: 'HH',\n    H: 'H',\n    hh: 'hh',\n    h: 'h',\n    mm: 'mm',\n    m: 'm',\n    ss: 'ss',\n    s: 's',\n    A: 'a',\n    a: 'a',\n  }\n\n  // Replace each token in the format string\n  return Object.keys(formatMap).reduce(\n    (acc, key) => acc.replace(new RegExp(key, 'g'), formatMap[key]),\n    momentFormat,\n  )\n}\n","import {TZDateMini} from '@date-fns/tz'\nimport {UTCDateMini} from '@date-fns/utc'\nimport {parse as dateFnsParse, parseISO} from 'date-fns'\n\nimport formatMomentLike from './datetime-formatter/formatter'\nimport {momentToDateFnsFormat} from './datetime-formatter/momentToDateFnsFormat'\nimport sanitizeLocale from './datetime-formatter/sanitizeLocale'\n\nexport {sanitizeLocale}\n\nexport const DEFAULT_DATE_FORMAT = 'YYYY-MM-DD'\nexport const DEFAULT_TIME_FORMAT = 'HH:mm'\n// take local as default time zone\nconst DEFAULT_TIMEZONE = Intl.DateTimeFormat().resolvedOptions().timeZone\n\nexport type ParseResult = {isValid: boolean; date?: Date; error?: string} & (\n  | {isValid: true; date: Date}\n  | {isValid: false; error?: string}\n)\n\nexport function format(\n  input: Date,\n  dateFormat: string,\n  options: {useUTC?: boolean; timeZone?: string} = {useUTC: false, timeZone: undefined},\n): string {\n  const {useUTC, timeZone} = options\n\n  if (useUTC) return formatMomentLike(new UTCDateMini(input), dateFormat)\n  return formatMomentLike(\n    timeZone ? new TZDateMini(input, timeZone || DEFAULT_TIMEZONE) : new Date(input),\n    dateFormat,\n  )\n}\n\n/*\n  It would be so good to remove date-fns from this file, but it's used in the parse function. We could write our own parser,\n  but this is better than moment.\n */\nexport function parse(dateString: string, dateFormat?: string, timeZone?: string): ParseResult {\n  const dnsFormat = dateFormat ? momentToDateFnsFormat(dateFormat) : undefined\n\n  // parse string to date using the format string from date-fns\n  const parsed = dnsFormat ? dateFnsParse(dateString, dnsFormat, new Date()) : parseISO(dateString)\n  if (parsed && !isNaN(parsed.getTime())) {\n    const parsedDate =\n      timeZone && isValidTimeZoneString(timeZone) ? new TZDateMini(parsed, timeZone) : parsed\n    return {isValid: true, date: parsedDate}\n  }\n  return {isValid: false, error: `Invalid date. Must be on the format \"${dateFormat}\"`}\n}\n\nexport function isValidTimeZoneString(timeZone: string): boolean {\n  return Intl.supportedValuesOf('timeZone').includes(timeZone)\n}\n"],"names":["format","dateFnsParse"],"mappings":"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"}